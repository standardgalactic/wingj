% Copyright (c) 2010-2013 Thomas Schaffter, Ricard Delgado-Gonzalo
%
% We release this software open source under a Creative Commons Attribution
% -NonCommercial 3.0 Unported License. Please cite the papers listed on 
% http://lis.epfl.ch/wingj when using WingJ in your publication.
%
% For commercial use, please contact Thomas Schaffter 
% (thomas.schaff...@gmail.com).
%
% A brief description of the license is available at 
% http://creativecommons.org/licenses/by-nc/3.0/ and the full license at 
% http://creativecommons.org/licenses/by-nc/3.0/legalcode.
%
% The above copyright notice and this permission notice shall be included 
% in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
% OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
% IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
% CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
% OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
% THE USE OR OTHER DEALINGS IN THE SOFTWARE.
%
% This class represents a 2D expression dataset generated by WingJ.
%
% An expression map is a square image containing the expression data of a
% 2D structure in a disc-shape map centered on the image.
%
% The 'offset' correspond to the parameter used to determine which portion
% of the map comes from the A/P or D/V expression map. -100 means that the
% expression map conserves the D/V boundary. 100 means that the expression
% map conserves the A/P boundary.
%
% See the Supplementary Material for more information about how expression
% profiles are generated in WingJ.
%
% Author: Thomas Schaffter (thomas.schaff...@gmail.com)
% Version: September 10, 2012
classdef ExpressionMap < handle
    
    properties(Constant)
        % Extension of the expression map (.tif)
        mapExt = '.tif';
    end
    
    properties(GetAccess = 'public', SetAccess = 'private')
        
        % Name of the experiment (standardized)
        name = '';
        % Gene name.
        geneName = '';
        % Original name of the file (without path)
        filename = '';
        
        % Expression map (tif).
        expressionMap = [];
        
        % Offset from -100 (only D/V boundary conserved) to 100 (only A/P boundary conserved).
        offset = [];
    end
    
    methods (Static)
        % Return the offset from the filename only. This method has been
        % designed to know the offset and then decide to load the dataset
        % or not.
        function offset_d = getOffset(rootFilename)
            tokens=regexp(rootFilename,filesep,'split');
            tokens=regexp(tokens{end},'_','split');
            offset_d = str2double(tokens{end});
        end
    end
    
    % =====================================================================
	% PRIVATE METHODS
    
    methods (Access = private)
        
        % Initialize
        function initialize(obj, experimentName, rootFilename)
            
            % open input image
            obj.openExpressionMap([rootFilename ExpressionMap.mapExt]);
            % set the dataset name
            tokens=regexp(rootFilename,filesep,'split');
            obj.setFilename(tokens{end});
            
            tokens=regexp(tokens{end},'_','split');
            
            % Set gene name
            obj.setGeneName(tokens{1});
            % Gets and sets offset
            offset_d = str2double(tokens{end});
            obj.setOffset(offset_d);
            if ~isnan(offset_d)
                % Set experiment name
                obj.setName([experimentName '_' obj.geneName '_' num2str(obj.offset)]);
            else
                % Set experiment name
                obj.setName([experimentName '_' obj.geneName]);
            end
        end
        
        % -----------------------------------------------------------------
        
        % Opens the expression map.
        function openExpressionMap(obj, filename)
            obj.expressionMap = imread(filename);
        end
    end
    
    % =====================================================================
	% PUBLIC METHODS
    
    methods
        
        % Constructor
        function obj = ExpressionMap(experimentName, rootFilename)
            if nargin > 0
                obj.initialize(experimentName, rootFilename);
            end
        end
        
        % -----------------------------------------------------------------
         
        % Shows the given expression maps.
        function showExpressionMaps(obj, galery, numImgPerLine, mytitles)
            
            if nargin < 2
                galery = true;
            end
            if nargin < 3
                numImgPerLine = 4;
            end
%             if nargin < 4
%                 mytitles = {};
%             end
            
            % Get all the images and place them in a cell array. Idem for
            % the image title. First load the images if required and count
            % the number of effective images.
            Neff = 0;
            for i=1:length(obj)
                m = obj(i);
                if ~isempty(m.expressionMap)
                    Neff = Neff+1;
                end
            end
            
            % Build the list of images
            I = cell(Neff,1);
            titles = cell(Neff,1);
            for i=1:length(obj)
                m = obj(i);
                if ~isempty(m.expressionMap)
                    I{i} = m.expressionMap;
                    titles{i} = regexprep(m.name, '_', '\_');
                end
            end      
            
            % Use the given titles (if any given)
            if exist('mytitles','var')
                % If a single string is given, add indexes
                if size(mytitles,1)==1
                    indexesStr = arrayfun(@num2str, 1:Neff, 'unif', 0);
                    titles = cellfun(@(c)[mytitles c],indexesStr,'uni',false);
                else
                    titles = mytitles;
                end
            end
            
            % Show the galery
            if ~isempty(I)
                show_image_galery(I,titles,galery,numImgPerLine);
            end
        end
        
        % -----------------------------------------------------------------
        
        % Shows mean expression maps.
        function meanMap = showMeanExpressionMap(obj)
            
            meanMap = obj.computeMeanExpressionMap();
            imshow(meanMap);
        end
        
        % -----------------------------------------------------------------
        
        % Shows mean expression maps.
        function stdMap = showStdExpressionMap(obj)
            
            stdMap = obj.computeStdExpressionMap();
            
            imagesc(stdMap); hold on;
            imageSize = size(stdMap);
            circle(imageSize/2,min(imageSize)/2,1000,'w--'); hold off;
            set(gca,'XTick',[]);
            set(gca,'YTick',[]);
            clim = get(gca,'CLim');
            set(gca, 'CLim',[0 clim(2)]);
            
            axis square
            colormap(hot(128));
            cbh = colorbar;
            set(get(cbh,'YLabel'),'String', ['Expression standard deviation (n=' num2str(length(obj)) ')']);
        end
        
        % -----------------------------------------------------------------
        
        % Returns a 3D array containing the information of the given
        % ExpressionMap objects.
        function data = to3dUint8Array(obj)
            
            A = [obj.expressionMap];
            data = reshape(A,[size(obj(1).expressionMap) length(obj)]);
        end
        
        % -----------------------------------------------------------------
        
        % Computes the mean expression map from the given ExpressionMap
        % objects.
        function meanMap = computeMeanExpressionMap(obj)
            
            data = obj.to3dUint8Array();
            meanMap = uint8(mean(data,3));
        end
        
        % -----------------------------------------------------------------
        
        % Computes the standard error expression map from the given
        % ExpressionMap objects.
        function stdMap = computeStdExpressionMap(obj)
           
            data = obj.to3dUint8Array();
            stdMap = std(double(data),0,3);
        end
                
        % -----------------------------------------------------------------
        
        % Returns the sum of the pixel values. A binary mask can be
        % provided.
        function expressionSum = sumExpression(obj, mask)
        
            expressionSum = zeros(length(obj),1);
            for i=1:length(obj)
                % stretch the image
                data = obj(i).expressionMap(:);
                % apply mask
                if nargin > 1 && ~isempty(mask(i))
                    % stretch the mask and ensure it is binary
                    m = mask(i).expressionMap(:) > 0;
                    % delete the data outside the mask
                    data(~m) = [];
                end
                expressionSum(i) = sum(data);
            end
        end
        
        % =================================================================
        % SETTERS AND GETTERS
                
        % Sets the name of the experiment.
        function setName(obj, name)
            obj.name = name;
        end
        
        % -----------------------------------------------------------------
        
        % Sets the name of the gene expressed.
        function setGeneName(obj, geneName)
            obj.geneName = geneName;
        end
        
        % -----------------------------------------------------------------
        
        % Sets the name of the file (without path)
        function setFilename(obj, filename)
            obj.filename = filename;
        end
        
        % -----------------------------------------------------------------
        
        % Sets the offset used to generate the expression map.
        function setOffset(obj, offset)
            obj.offset = offset;
        end
        
    end
end